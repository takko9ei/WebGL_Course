<!DOCTYPE html>
<html>
  <head>
    <title>WebGL HW2 - Ramiel Scene with Dynamic Depth Gradients</title>
    <style>
      body {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        background: #333;
      }
      canvas {
        border: 1px solid white;
        border-radius: 18px;
      }
    </style>
  </head>
  <body>
    <canvas id="glCanvas" width="640" height="480"></canvas>

    <script id="vertex-shader" type="notjs">
      #version 300 es

      in vec3 pos;

      uniform mat4 uModelMatrix;
      uniform mat4 uViewMatrix;
      uniform mat4 uProjectionMatrix;

      out float vDepth;

      void main() {
        // Calculate the position in View Space (relative to the camera)
        vec4 viewPosition = uViewMatrix * uModelMatrix * vec4(pos, 1.0);

        // Calculate the final position in Clip Space
        gl_Position = uProjectionMatrix * viewPosition;

        // Pass the Z-coordinate (depth) to the fragment shader.
        // In View Space:
        // 0 is the camera lens.
        // Negative values are in front of the camera.
        // e.g., -5 is closer than -20.
        vDepth = viewPosition.z;
      }
    </script>

    <script id="fragment-shader" type="notjs">
      #version 300 es
      precision mediump float;

      in float vDepth;

      uniform vec3 uBaseColor;

      // uDepthNear: The Z value where brightness is maximum (closest visible point)
      // uDepthFar:  The Z value where brightness is minimum (farthest visible point)
      uniform float uDepthNear;
      uniform float uDepthFar;

      // Output: The final pixel color
      out vec4 color_out;

      void main() {
        // Normalize vDepth based on the specific object's range.
        // Result: 0.0 at far limit, 1.0 at near limit.
        float depthFactor = (vDepth - uDepthFar) / (uDepthNear - uDepthFar);

        depthFactor = clamp(depthFactor, 0.0, 1.0);

        float brightness = mix(0.2, 1.0, depthFactor);

        // Final color calculation
        color_out = vec4(uBaseColor * brightness, 1.0);
      }
    </script>

    <script>
      //mini mat lib
      const MiniMat = {
        create: () => new Float32Array(16),
        identity: (out) => {
          out.fill(0);
          out[0] = out[5] = out[10] = out[15] = 1;
          return out;
        },
        multiply: (out, a, b) => {
          let a00 = a[0],
            a01 = a[1],
            a02 = a[2],
            a03 = a[3];
          let a10 = a[4],
            a11 = a[5],
            a12 = a[6],
            a13 = a[7];
          let a20 = a[8],
            a21 = a[9],
            a22 = a[10],
            a23 = a[11];
          let a30 = a[12],
            a31 = a[13],
            a32 = a[14],
            a33 = a[15];
          let b0 = b[0],
            b1 = b[1],
            b2 = b[2],
            b3 = b[3];
          out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = b[4];
          b1 = b[5];
          b2 = b[6];
          b3 = b[7];
          out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = b[8];
          b1 = b[9];
          b2 = b[10];
          b3 = b[11];
          out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = b[12];
          b1 = b[13];
          b2 = b[14];
          b3 = b[15];
          out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          return out;
        },
        perspective: (out, fovy, aspect, near, far) => {
          const f = 1.0 / Math.tan(fovy / 2);
          out.fill(0);
          out[0] = f / aspect;
          out[5] = f;
          out[10] = (far + near) / (near - far);
          out[11] = -1;
          out[14] = (2 * far * near) / (near - far);
          return out;
        },
        lookAt: (out, eye, center, up) => {
          let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
          z0 = eye[0] - center[0];
          z1 = eye[1] - center[1];
          z2 = eye[2] - center[2];
          len = 1 / Math.hypot(z0, z1, z2);
          z0 *= len;
          z1 *= len;
          z2 *= len;
          x0 = up[1] * z2 - up[2] * z1;
          x1 = up[2] * z0 - up[0] * z2;
          x2 = up[0] * z1 - up[1] * z0;
          len = 1 / Math.hypot(x0, x1, x2);
          x0 *= len;
          x1 *= len;
          x2 *= len;
          y0 = z1 * x2 - z2 * x1;
          y1 = z2 * x0 - z0 * x2;
          y2 = z0 * x1 - z1 * x0;
          out[0] = x0;
          out[1] = y0;
          out[2] = z0;
          out[3] = 0;
          out[4] = x1;
          out[5] = y1;
          out[6] = z1;
          out[7] = 0;
          out[8] = x2;
          out[9] = y2;
          out[10] = z2;
          out[11] = 0;
          out[12] = -(x0 * eye[0] + x1 * eye[1] + x2 * eye[2]);
          out[13] = -(y0 * eye[0] + y1 * eye[1] + y2 * eye[2]);
          out[14] = -(z0 * eye[0] + z1 * eye[1] + z2 * eye[2]);
          out[15] = 1;
          return out;
        },
        translate: (out, a, v) => {
          if (a !== out) MiniMat.identity(out);
          out[12] = a[12] + v[0];
          out[13] = a[13] + v[1];
          out[14] = a[14] + v[2];
          return out;
        },
        rotate: (out, a, rad, axis) => {
          let x = axis[0],
            y = axis[1],
            z = axis[2],
            len = Math.hypot(x, y, z);
          if (len < 1e-6) return null;
          len = 1 / len;
          x *= len;
          y *= len;
          z *= len;
          let s = Math.sin(rad),
            c = Math.cos(rad),
            t = 1 - c;
          let a00 = a[0],
            a01 = a[1],
            a02 = a[2],
            a03 = a[3];
          let a10 = a[4],
            a11 = a[5],
            a12 = a[6],
            a13 = a[7];
          let a20 = a[8],
            a21 = a[9],
            a22 = a[10],
            a23 = a[11];
          let b00 = x * x * t + c,
            b01 = y * x * t + z * s,
            b02 = z * x * t - y * s;
          let b10 = x * y * t - z * s,
            b11 = y * y * t + c,
            b12 = z * y * t + x * s;
          let b20 = x * z * t + y * s,
            b21 = y * z * t - x * s,
            b22 = z * z * t + c;
          out[0] = a00 * b00 + a10 * b01 + a20 * b02;
          out[1] = a01 * b00 + a11 * b01 + a21 * b02;
          out[2] = a02 * b00 + a12 * b01 + a22 * b02;
          out[3] = a03 * b00 + a13 * b01 + a23 * b02;
          out[4] = a00 * b10 + a10 * b11 + a20 * b12;
          out[5] = a01 * b10 + a11 * b11 + a21 * b12;
          out[6] = a02 * b10 + a12 * b11 + a22 * b12;
          out[7] = a03 * b10 + a13 * b11 + a23 * b12;
          out[8] = a00 * b20 + a10 * b21 + a20 * b22;
          out[9] = a01 * b20 + a11 * b21 + a21 * b22;
          out[10] = a02 * b20 + a12 * b21 + a22 * b22;
          out[11] = a03 * b20 + a13 * b21 + a23 * b22;
          if (a !== out) {
            out[12] = a[12];
            out[13] = a[13];
            out[14] = a[14];
            out[15] = a[15];
          }
          return out;
        },
      };

      //#region geo data
      const floorVertices = [
        -10.0, -2.5, 10.0, 10.0, -2.5, 10.0, -10.0, -2.5, -10.0, 10.0, -2.5,
        -10.0,
      ];

      const vTop = [0.0, 2.2, 0.0];
      const vBottom = [0.0, -2.2, 0.0];
      const vLeft = [-2.0, 0.0, 0.0];
      const vRight = [2.0, 0.0, 0.0];
      const vFront = [0.0, 0.0, 2.0];
      const vBack = [0.0, 0.0, -2.0];

      //we need to send the data twice, to FORCE use strip draw shape
      const ramielTopStrip = [
        ...vTop,
        ...vLeft,
        ...vFront,
        ...vBottom,
        ...vRight,
        ...vBack,
      ];
      const ramielBottomStrip = [
        ...vBottom,
        ...vLeft,
        ...vBack,
        ...vTop,
        ...vRight,
        ...vFront,
      ];
      const ramielVertices = [...ramielTopStrip, ...ramielBottomStrip];
      //#endregion

      //#region initialize
      const canvas = document.getElementById("glCanvas");

      /** @type {WebGL2RenderingContext} */
      const gl = canvas.getContext("webgl2");
      if (!gl) throw new Error("WebGL 2.0 unsupported!");

      gl.clearColor(163 / 255, 208 / 255, 1.0, 1.0); // Darker background for better contrast
      gl.enable(gl.DEPTH_TEST);
      //#endregion

      //#region shader set
      const vsSource = document.getElementById("vertex-shader").text.trim();
      const fsSource = document.getElementById("fragment-shader").text.trim();
      const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
      gl.useProgram(shaderProgram);
      //#endregion

      //#region locations
      const posAttrib = gl.getAttribLocation(shaderProgram, "pos");
      const uniformLocations = {
        modelMatrix: gl.getUniformLocation(shaderProgram, "uModelMatrix"),
        viewMatrix: gl.getUniformLocation(shaderProgram, "uViewMatrix"),
        projectionMatrix: gl.getUniformLocation(
          shaderProgram,
          "uProjectionMatrix"
        ),
        baseColor: gl.getUniformLocation(shaderProgram, "uBaseColor"),
        // UNIFORMS for gradient control
        depthNear: gl.getUniformLocation(shaderProgram, "uDepthNear"),
        depthFar: gl.getUniformLocation(shaderProgram, "uDepthFar"),
      };
      //#endregion

      //#region geometry setup
      function initGeometry(gl, program, vertices) {
        const vao = gl.createVertexArray();
        const vbo = gl.createBuffer();
        gl.bindVertexArray(vao);
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(vertices),
          gl.STATIC_DRAW
        );
        gl.enableVertexAttribArray(posAttrib); //vao works here
        gl.vertexAttribPointer(posAttrib, 3, gl.FLOAT, false, 0, 0); //vao works here
        gl.bindVertexArray(null);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        return { vao: vao, count: vertices.length / 3 };
      }

      const floorGeometry = initGeometry(gl, shaderProgram, floorVertices);
      const ramielGeometry = initGeometry(gl, shaderProgram, ramielVertices);

      //#endregion

      //#region Rendering
      const projectionMatrix = MiniMat.create();
      MiniMat.perspective(
        projectionMatrix,
        (45 * Math.PI) / 180,
        canvas.clientWidth / canvas.clientHeight,
        0.1,
        100.0
      );

      //cam set
      const viewMatrix = MiniMat.create();
      //camera at (0, 2, 15), looking at (0, 0, 0)
      //view space Z will be approx -15
      MiniMat.lookAt(viewMatrix, [0, 2, 15], [0, 0, 0], [0, 1, 0]);

      const floorModelMatrix = MiniMat.create();
      MiniMat.identity(floorModelMatrix);

      const ramielModelMatrix = MiniMat.create();

      function drawScene(time) {
        time *= 0.001;

        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        //"global" uniforms
        gl.uniformMatrix4fv(
          uniformLocations.projectionMatrix,
          false,
          projectionMatrix
        );
        gl.uniformMatrix4fv(uniformLocations.viewMatrix, false, viewMatrix);

        //floor draw
        gl.bindVertexArray(floorGeometry.vao);
        gl.uniformMatrix4fv(
          uniformLocations.modelMatrix,
          false,
          floorModelMatrix
        );
        gl.uniform3f(uniformLocations.baseColor, 0.5, 0.5, 0.5); //grey

        //floor gradient
        //Floor span 10,-10. Camera is at 15
        //Nearest point dist 5, view z =-5
        //Farthest point dist 25, view z =-25
        //set the range to cover this, fading to black at the back.
        gl.uniform1f(uniformLocations.depthNear, -4.0);
        gl.uniform1f(uniformLocations.depthFar, -30.0);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, floorGeometry.count);

        //ramiel draw
        gl.bindVertexArray(ramielGeometry.vao);
        MiniMat.identity(ramielModelMatrix);
        MiniMat.rotate(
          ramielModelMatrix,
          ramielModelMatrix,
          time * 0.5,
          [0, 1, 0]
        );
        gl.uniformMatrix4fv(
          uniformLocations.modelMatrix,
          false,
          ramielModelMatrix
        );
        gl.uniform3f(uniformLocations.baseColor, 0.2, 0.4, 1.0); //blue

        //gradient setting like floor
        gl.uniform1f(uniformLocations.depthNear, -12.0); //brightest(shallow)
        gl.uniform1f(uniformLocations.depthFar, -15.2); //darkest(deep)

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, ramielGeometry.count);

        requestAnimationFrame(drawScene);
      }

      requestAnimationFrame(drawScene);
      //#endregion

      //#region shader compile helper
      function initShaderProgram(gl, vsSource, fsSource) {
        const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
        if (!vertexShader || !fragmentShader) return null;
        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
          alert(
            "Unable to initialize the shader program: " +
              gl.getProgramInfoLog(shaderProgram)
          );
          return null;
        }
        return shaderProgram;
      }
      function loadShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error("Shader compile error: " + gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }
      //#endregion
    </script>
  </body>
</html>
