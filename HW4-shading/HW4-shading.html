<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

    <title>WebGL Shading Template with 2D Procedural Noise Texture</title>
  </head>
  <body>
    <canvas id="glCanvas" style="width: 400px; height: 400px"></canvas>

    <script id="vertex-shader" type="notjs">
      #version 300 es
      precision mediump float;
      in vec4 a_position;
      in vec4 a_normal;
      in vec2 a_texCoord;

      out vec3 v_worldPos;
      out vec3 v_normal;
      out vec2 v_texCoord;

      uniform float u_time;

      const float M_PI = 3.14159265358979323846;  /* pi */

      void main() {
          const float theta = M_PI / 4.0;
          float c = cos(theta);
          float s = sin(theta);
          mat4 Rx = mat4(
             1.0, 0.0, 0.0, 0.0,
             0.0,  c,   s,  0.0,
             0.0, -s,   c,  0.0,
             0.0, 0.0, 0.0, 1.0
          );

          float phi = u_time / 4.0;
          c = cos(phi);
          s = sin(phi);
          mat4 Ry = mat4(
              c,  0.0, -s,  0.0,
             0.0, 1.0, 0.0, 0.0,
              s,  0.0,  c,  0.0,
             0.0, 0.0, 0.0, 1.0
          );

          float psi = M_PI / 16.0;
          c = cos(psi);
          s = sin(psi);
          mat4 Rz = mat4(
              c,   s,  0.0, 0.0,
             -s,   c,  0.0, 0.0,
             0.0, 0.0, 1.0, 0.0,
             0.0, 0.0, 0.0, 1.0
          );

          const float sca = 0.5;
          const mat4 S = mat4(
             sca, 0.0, 0.0, 0.0,
             0.0, sca, 0.0, 0.0,
             0.0, 0.0, sca, 0.0,
             0.0, 0.0, 0.0, 1.0
          );

          // Model Matrix
          mat4 H = Ry * Rz * Rx * S;

          //world position
          gl_Position = H * a_position;
          v_worldPos = gl_Position.xyz;

          //transform normal
          v_normal = mat3(H) * a_normal.xyz;

          v_texCoord = a_texCoord;
      }
    </script>
    <script id="fragment-shader" type="notjs">
      #version 300 es
      precision mediump float;

      in vec3 v_worldPos;
      in vec3 v_normal;
      in vec2 v_texCoord;

      out vec4 color_out;

      uniform float u_time;

      float pseudoRand2D(vec2 p) {
          p = fract(p * vec2(123.34, 456.21));
          p += dot(p, p + 45.32);
          return fract(p.x * p.y);
      }

      float noise2D(vec2 st) {
          vec2 i = floor(st);
          vec2 f = fract(st);

          //smoothstep
          f = f * f * (3.0 - 2.0 * f);

          float a = pseudoRand2D(i);
          float b = pseudoRand2D(i + vec2(1.0, 0.0));
          float c = pseudoRand2D(i + vec2(0.0, 1.0));
          float d = pseudoRand2D(i + vec2(1.0, 1.0));

          return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
      }

      void main() {
          vec3 N = normalize(v_normal);
          //although this is parallel projection, do not need cam pos to render basic shape, but we need view vector to apply lighting
          vec3 V = normalize(vec3(0.0, 0.0, 5.0) - v_worldPos);

          //sampling
          float noiseVal = noise2D(v_texCoord * 8.0);

          vec3 baseColor = mix(vec3(0.1686, 0.192, 0.28), vec3(0.72,0.77647, 0.87), smoothstep(0.2, 0.8, noiseVal));

          //lightings
          vec3 lighting = vec3(0.0);

          //ambient
          vec3 ambient = vec3(0.3, 0.3, 0.3);
          lighting += ambient;

          //directional
          vec3 dirLightDir = normalize(vec3(1.0, 1.0, -0.5)); // From top-right-front
          vec3 dirLightColor = 1.3*vec3(0.72549,0.651,1.0);
          //dir diffuse
          float diff1 = max(dot(N, dirLightDir), 0.0);
          //dir specular
          vec3 H1 = normalize(dirLightDir + V);
          float spec1 = pow(max(dot(N, H1), 0.0), 32.0);
          lighting += (diff1 * dirLightColor) + (spec1 * vec3(1.0));

          //point
          //point need attenuation
          vec3 pointLightPos = normalize(vec3(-1.0, 1.0, -2.0));
          vec3 pointLightColor = vec3(1.0, 0.651, 0.91);
          vec3 L_pointVec = pointLightPos - v_worldPos;
          float dist = length(L_pointVec);
          vec3 L_point = normalize(L_pointVec);
          //point diffuse
          float diff2 = max(dot(N, L_point), 0.0);
          //attenuation
          float attenuation = 1.0/(dist*dist);
          //point specular
          vec3 H2 = normalize(L_point + V);
          float spec2 = pow(max(dot(N, H2), 0.0), 32.0);

          lighting += (diff2 * pointLightColor * attenuation) + (spec2 * pointLightColor * attenuation);

          color_out = vec4(baseColor * lighting, 1.0);
      }
    </script>
    <script type="text/javascript">
      function createProgram(gl, vertexSrc, fragmentSrc) {
        let vshd = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vshd, vertexSrc);
        gl.compileShader(vshd);
        if (!gl.getShaderParameter(vshd, gl.COMPILE_STATUS))
          throw new Error(
            "Unable to compile shader: " + gl.getShaderInfoLog(vshd)
          );
        let fshd = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fshd, fragmentSrc);
        gl.compileShader(fshd);
        if (!gl.getShaderParameter(fshd, gl.COMPILE_STATUS))
          throw new Error(
            "Unable to compile shader: " + gl.getShaderInfoLog(fshd)
          );
        let prog = gl.createProgram();
        gl.attachShader(prog, vshd);
        gl.attachShader(prog, fshd);
        gl.linkProgram(prog);
        if (!gl.getProgramParameter(prog, gl.LINK_STATUS))
          throw new Error(
            "Unable to link program: " + gl.getProgramInfoLog(prog)
          );
        return prog;
      }

      function init() {
        var c = document.getElementById("glCanvas");

        /** @type {WebGL2RenderingContext} */
        var gl = c.getContext("webgl2");

        if (!gl) throw new Error("WebGL unsupported!");

        // Clear screen
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        // VBO 0: Positions
        var vertexPosBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBuffer);
        const vertices = [
          // Front face
          -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0,

          // Back face
          -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0,

          // Top face
          -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0,

          // Bottom face
          -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0,

          // Right face
          1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, 1.0, -1.0, 1.0,

          // Left face
          -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, -1.0,
        ];
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(vertices),
          gl.STATIC_DRAW
        );
        vertexPosBuffer.itemSize = 3;
        vertexPosBuffer.numItems = 4 * 6;

        // VBO 1: Normals
        var normalPosBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, normalPosBuffer);
        const normals = [
          // Front face
          0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0,

          // Back face
          0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0,

          // Top face
          0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0,

          // Bottom face
          0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0,

          // Right face
          1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0,

          // Left face
          -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0,
        ];
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(normals),
          gl.STATIC_DRAW
        );
        normalPosBuffer.itemSize = 3;
        normalPosBuffer.numItems = 4 * 6;

        // VBO 2: Texture Coordinates (UVs)
        // 为每个面的四个顶点定义 (0,0) 到 (1,1) 的映射
        var texCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
        const texCoords = [
          // Front face
          0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,
          // Back face
          1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0,
          // Top face
          0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0,
          // Bottom face
          1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0,
          // Right face
          1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0,
          // Left face
          0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,
        ];
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(texCoords),
          gl.STATIC_DRAW
        );
        texCoordBuffer.itemSize = 2;
        texCoordBuffer.numItems = 4 * 6;

        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        // This array defines each face as two triangles, using the
        // indices into the vertex array to specify each triangle's
        // position.
        const indices = [
          0,
          1,
          2,
          0,
          2,
          3, // front
          4,
          5,
          6,
          4,
          6,
          7, // back
          8,
          9,
          10,
          8,
          10,
          11, // top
          12,
          13,
          14,
          12,
          14,
          15, // bottom
          16,
          17,
          18,
          16,
          18,
          19, // right
          20,
          21,
          22,
          20,
          22,
          23, // left
        ];
        gl.bufferData(
          gl.ELEMENT_ARRAY_BUFFER,
          new Uint16Array(indices),
          gl.STATIC_DRAW
        );

        // Create our shader program
        var vs = document.querySelector("#vertex-shader").text.trim();
        var fs = document.querySelector("#fragment-shader").text.trim();
        var program = createProgram(gl, vs, fs);
        gl.useProgram(program);

        // Get the vertex attribute
        program.vertexPosAttrib = gl.getAttribLocation(program, "a_position");
        program.normalPosAttrib = gl.getAttribLocation(program, "a_normal");
        program.texCoordAttrib = gl.getAttribLocation(program, "a_texCoord");

        // Remember to add and use u_time uniform in your shaders
        var u_time_loc = gl.getUniformLocation(program, "u_time");

        gl.enable(gl.DEPTH_TEST);

        function render(ms_since_page_loaded) {
          // Convert to seconds and send to shader
          gl.uniform1f(u_time_loc, ms_since_page_loaded * 0.001);

          // Draw scene here using uniform float u_time to animate
          // Below is an example using the relevant code from the WebGL skeleton
          gl.useProgram(program);

          // Vertices
          gl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBuffer);
          gl.enableVertexAttribArray(program.vertexPosAttrib);
          gl.vertexAttribPointer(
            program.vertexPosAttrib,
            vertexPosBuffer.itemSize,
            gl.FLOAT,
            false,
            0,
            0
          );

          // Normals
          gl.bindBuffer(gl.ARRAY_BUFFER, normalPosBuffer);
          gl.enableVertexAttribArray(program.normalPosAttrib);
          gl.vertexAttribPointer(
            program.normalPosAttrib,
            normalPosBuffer.itemSize,
            gl.FLOAT,
            false,
            0,
            0
          );

          //texcoord
          gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
          gl.enableVertexAttribArray(program.texCoordAttrib);
          gl.vertexAttribPointer(
            program.texCoordAttrib,
            texCoordBuffer.itemSize,
            gl.FLOAT,
            false,
            0,
            0
          );

          // Indices
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

          // Draw
          gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);

          // Request animation again
          requestAnimationFrame(render);
        }

        // First render which will request animation
        render(0);
      }
      window.onload = init;
    </script>
  </body>
</html>
