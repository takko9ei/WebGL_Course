<!DOCTYPE html>
<html>
  <head>
    <title>GL 最小示例: attribute, uniform, varying</title>
    <style>
      body {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        background: #333;
      }
      canvas {
        border: 1px solid white;
      }
    </style>
  </head>
  <body>
    <canvas id="glCanvas" width="600" height="400"></canvas>

    <script id="vertex-shader" type="x-shader/x-vertex">
      // --- 1. ATTRIBUTE ---
      // 'attribute' 类型的变量，从 JavaScript 的“缓冲区”接收数据。
      // 每个顶点的数据都不同。
      attribute vec3 a_position; // 接收顶点的(x, y, z)坐标
      attribute vec3 a_color;    // 接收顶点的(r, g, b)颜色

      // --- 2. UNIFORM ---
      // 'uniform' 类型的变量，从 JavaScript 接收一个“全局”数据。
      // 在处理 *所有* 顶点时，这个值都是相同的。
      uniform vec2 u_offset; // 接收一个全局的(x, y)偏移量

      // --- 3. VARYING ---
      // 'varying' 类型的变量，作为从 VS 到 FS 的“桥梁”。
      // 我们在这里给它赋值。
      varying vec3 v_color;

      void main() {
          // 'gl_Position' 是一个内置的输出变量，必须被设置。
          // 它决定了顶点在屏幕上的最终位置。
          // 我们将 attribute 的位置 加上 uniform 的偏移量。
          gl_Position = vec4(a_position.xy + u_offset, a_position.z, 1.0);

          // 将 'attribute' (每个顶点的颜色) 传递给 'varying' 变量。
          // GPU 稍后会自动为我们“插值”这个颜色。
          v_color = a_color;
      }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
      // 浮点数精度声明 (在片元着色器中必须)
      precision mediump float;

      // --- 3. VARYING (接收端) ---
      // 变量名必须与 VS 中的 'varying' *完全一致*。
      // 它接收的值是 GPU 根据片元位置自动“插值”后的结果。
      varying vec3 v_color;

      void main() {
          // 'gl_FragColor' 是一个内置的输出变量。
          // 它决定了当前片元(像素)的最终颜色。
          // 我们直接使用从 VS 传过来并被插值后的 v_color。
          gl_FragColor = vec4(v_color, 1.0);
      }
    </script>

    <script>
      // -- A. 初始化 --
      const canvas = document.getElementById("glCanvas");
      const gl = canvas.getContext("webgl"); // Get the WebGL rendering context

      // Get shader source code from the <script> tags
      const vsSource = document.getElementById("vertex-shader").text;
      const fsSource = document.getElementById("fragment-shader").text;

      // Compile and link the shaders into a 'program'
      const shaderProgram = initShaderProgram(gl, vsSource, fsSource);

      // Tell WebGL to use this program for drawing
      gl.useProgram(shaderProgram);

      // -- B. 准备数据 --

      // 我们的三角形数据。
      // 它在一个数组中混合了“位置”和“颜色”数据。
      // 顶点 1: (0, 0.5, 0)   -> 红色 (1, 0, 0)
      // 顶点 2: (-0.5, -0.5, 0) -> 绿色 (0, 1, 0)
      // 顶点 3: (0.5, -0.5, 0)  -> 蓝色 (0, 0, 1)
      const vertexData = [
        // X, Y, Z      // R, G, B
        0.0, 0.5, 0.0, 1.0, 0.0, 0.0, -0.5, -0.5, 0.0, 0.0, 1.0, 0.0, 0.5, -0.5,
        0.0, 0.0, 0.0, 1.0,
      ];
      const vertexCount = 3; // We are drawing 3 vertices
      const bytesPerFloat = 4; // Size of a 32-bit float
      // Stride: The total number of bytes for *one vertex* (3 pos + 3 color)
      const stride = (3 + 3) * bytesPerFloat;

      // Create a buffer on the GPU
      const buffer = gl.createBuffer();
      // Bind the buffer as the "current" one
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      // Send our 'vertexData' from CPU to the GPU buffer
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array(vertexData),
        gl.STATIC_DRAW
      );

      // -- C. 连接 'attribute' 变量 --

      // 1. (attribute) 'a_position'
      // Get the "location" (pointer) of the 'a_position' attribute in the shader program
      const a_position_loc = gl.getAttribLocation(shaderProgram, "a_position");
      // Tell WebGL how to read data from the buffer for 'a_position'
      gl.vertexAttribPointer(
        a_position_loc, // The attribute location
        3, // Number of components per vertex (vec3 -> 3)
        gl.FLOAT, // Type of data
        false, // Normalize?
        stride, // Stride: 24 bytes total to get to the *next* vertex's position
        0 // Offset: 0 bytes from the start of the vertex data
      );
      gl.enableVertexAttribArray(a_position_loc); // Enable this attribute!

      // 2. (attribute) 'a_color'
      // Get the location of 'a_color'
      const a_color_loc = gl.getAttribLocation(shaderProgram, "a_color");
      // Tell WebGL how to read data for 'a_color'
      gl.vertexAttribPointer(
        a_color_loc,
        3, // Number of components (vec3 -> 3)
        gl.FLOAT,
        false,
        stride, // Stride: 24 bytes total to get to the *next* vertex's color
        3 * bytesPerFloat // Offset: 12 bytes from the start (skip the 3 position floats)
      );
      gl.enableVertexAttribArray(a_color_loc); // Enable this attribute!

      // -- D. 连接 'uniform' 变量 --

      // 1. (uniform) 'u_offset'
      // Get the location of 'u_offset'
      const u_offset_loc = gl.getUniformLocation(shaderProgram, "u_offset");
      // Set the value for this uniform. We'll shift the triangle 0.3 units to the right.
      // This value is GLOBAL for all vertices.
      gl.uniform2f(u_offset_loc, 0.3, 0.0); // Set (x=0.3, y=0.0)

      // -- E. 绘制 --

      // Clear the canvas to black
      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT);

      // Draw the triangles!
      gl.drawArrays(
        gl.TRIANGLES, // Draw mode
        0, // First vertex to draw
        vertexCount // Number of vertices to draw (3)
      );

      // --- 辅助函数：编译和链接着色器 ---
      function initShaderProgram(gl, vsSource, fsSource) {
        const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
          alert(
            "Unable to initialize the shader program: " +
              gl.getProgramInfoLog(shaderProgram)
          );
          return null;
        }
        return shaderProgram;
      }

      function loadShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          alert(
            "An error occurred compiling the shaders: " +
              gl.getShaderInfoLog(shader)
          );
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }
    </script>
  </body>
</html>
