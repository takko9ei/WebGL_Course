<html>
  <head>
    <title>Minimal WebGL Example</title>
    <!--  NOTICE: This is a minimum skeleton, rendering a square. 
          Compared with example given in class, this skeleton has clearer structure, and described how to use vbo, vao properly. 
          Also, this program runs under strict mode. -->
    <style>
      body {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        background: #333;
      }
      canvas {
        border: 1px solid white;
      }
    </style>
  </head>
  <body>
    <canvas id="glCanvas" style="width: 600px; height: 600px" />
    <!-- type="notjs" makes it not get identified as javascript. -->
    <script id="vertex-shader" type="notjs">
      #version 300 es
      in vec4 pos;
      out vec2 coord;
      void main() {
        coord = pos.xy;
        gl_Position = pos;
      }
    </script>
    <script id="fragment-shader" type="notjs">
          #version 300 es
      precision mediump float;

      in vec2 coord;
      out vec4 color_out;

      // --- 新增 uniform 变量 ---
      uniform float u_time; // 从 JS 传入的时间，用于动画

      //sdf
      float sdBox(in vec2 p, in vec2 b)
      {
          vec2 d = abs(p)-b;
          return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
      }

      void main() {

        vec2 half_size = vec2(1, 0.5); // 宽为画布宽度，高为一半

        // --- 颜色定义 (修改) ---
        vec3 color_dark_blue = vec3(0.1, 0.3, 0.7);  // 深蓝

        // --- 绘制 (修改) ---
        float d = sdBox(coord, half_size);
        float d1 = 1.0 - step(0.0, d);

        color_out = vec4(d1*color_dark_blue, 1.0);
      }
    </script>
    <script>
      "use strict";
      //#region variables
      const vertices = [-1, -1, 1, -1, -1, 1, 1, 1];
      //#endregion

      //#region initialization
      const canvas = document.getElementById("glCanvas");
      const gl = canvas.getContext("webgl2");
      if (!gl) throw new Error("WebGL unsupported!");
      //#endregion

      //#region shader setup
      const vsSource = document.getElementById("vertex-shader").text.trim();
      const fsSource = document.getElementById("fragment-shader").text.trim();
      const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
      gl.useProgram(shaderProgram);
      // --- 新增: 获取 uniform 变量的位置 ---
      const uTimeLocation = gl.getUniformLocation(shaderProgram, "u_time");
      //#endregion

      //#region bind
      let vbo = gl.createBuffer();
      let vao = gl.createVertexArray();
      gl.bindVertexArray(vao);
      gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array(vertices),
        gl.STATIC_DRAW
      );
      let vertexPosAttrib = gl.getAttribLocation(shaderProgram, "pos"); //返回“pos”入口的位置
      gl.enableVertexAttribArray(vertexPosAttrib); //“启用入口”
      gl.vertexAttribPointer(vertexPosAttrib, 2, gl.FLOAT, false, 0, 0); //index size type normalized stride offset
      gl.bindVertexArray(null);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      //#endregion

      requestAnimationFrame(render); // 启动动画循环
      //#endregion

      //#region shader helper functions
      function render(time) {
        time *= 0.001; // 转换为秒

        gl.clearColor(0.0, 0.0, 0.0, 1.0); // 设置清屏颜色为黑色
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.useProgram(shaderProgram); // 激活着色器程序
        gl.uniform1f(uTimeLocation, time); // 更新时间 uniform
        gl.bindVertexArray(vao); // 绑定 VAO
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4); // 绘制
        requestAnimationFrame(render); // 请求下一帧
      }

      function initShaderProgram(gl, vsSource, fsSource) {
        const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
        if (!vertexShader || !fragmentShader) return null;
        const shaderProgram = gl.createProgram(); //distinguish with createshader
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        //two colomns above can be reversed
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
          alert(
            "Unable to initialize the shader program: " +
              gl.getProgramInfoLog(shaderProgram)
          );
          return null;
        }
        return shaderProgram;
      }
      function loadShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        //if compile fail
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error(
            "An error occurred compiling the shaders: " +
              gl.getShaderInfoLog(shader)
          );
          alert(
            "An error occurred compiling the shaders. Check console for details."
          );
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }
      //#endregion
    </script>
  </body>
</html>
