<html>
  <head>
    <title>Drawing Letter A</title>
    <meta name="author" content="LI Zhuohang (5125EG13-0)" />
    <!--  NOTICE: Used skeleton implemented by my self. -->
    <style>
      body {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        background: #333;
      }
      canvas {
        border: 1px solid white;
      }
    </style>
  </head>
  <body>
    <canvas id="glCanvas" style="width: 400px; height: 400px" />
    <!-- type="notjs" makes it not get identified as javascript. -->
    <script id="vertex-shader" type="notjs">
      #version 300 es
      in vec4 pos;
      out vec2 coord;
      void main() {
        coord = pos.xy;
        gl_Position = pos;
      }
    </script>
    <script id="fragment-shader" type="notjs">
      #version 300 es
      precision mediump float;
      in vec2 coord;
      out vec4 color_out;
      float sdBox(in vec2 p, in vec2 b)
      {
          vec2 d = abs(p)-b;
          return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
      }
      float sdTrapezoid( in vec2 p, in float r1, float r2, float he )
      {
          vec2 k1 = vec2(r2,he);
          vec2 k2 = vec2(r2-r1,2.0*he);
          p.x = abs(p.x);
          vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);
          vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot(k2, k2), 0.0, 1.0 );
          float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;
          return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );
      }
      void main() {
        vec3 color_dark_blue = vec3(0.1, 0.3, 0.7);
        float d_contour = sdTrapezoid(coord,0.5,0.1,0.7);
        float d_lowerbool = sdTrapezoid(0.6*vec2(coord.x,coord.y+1.4),0.5,0.1,0.7);
        float d_upperbool = sdTrapezoid(vec2(coord.x,coord.y-0.1),0.125,0.025,0.175);
        float res0 = max(d_contour, -d_lowerbool);
        float res1 = max(res0, -d_upperbool);
        float d1 = 1.0 - smoothstep(-0.01, 0.01, res1);
        color_out = vec4(d1*color_dark_blue, 1.0);
      }
    </script>
    <script>
      "use strict";
      //#region variables
      const vertices = [-1, -1, 1, -1, -1, 1, 1, 1];
      //#endregion

      //#region initialization
      const canvas = document.getElementById("glCanvas");
      const gl = canvas.getContext("webgl2");
      if (!gl) throw new Error("WebGL unsupported!");
      //#endregion

      //#region shader setup
      const vsSource = document.getElementById("vertex-shader").text.trim();
      const fsSource = document.getElementById("fragment-shader").text.trim();
      const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
      gl.useProgram(shaderProgram);
      //#endregion

      //#region bind
      let vbo = gl.createBuffer();
      let vao = gl.createVertexArray();
      gl.bindVertexArray(vao);
      gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array(vertices),
        gl.STATIC_DRAW
      );
      let vertexPosAttrib = gl.getAttribLocation(shaderProgram, "pos"); //返回“pos”入口的位置
      gl.enableVertexAttribArray(vertexPosAttrib); //“启用入口”
      gl.vertexAttribPointer(vertexPosAttrib, 2, gl.FLOAT, false, 0, 0); //index size type normalized stride offset
      gl.bindVertexArray(null);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      //#endregion

      //#region draw
      gl.bindVertexArray(vao);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      //#endregion

      //#region shader helper functions
      function initShaderProgram(gl, vsSource, fsSource) {
        const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
        if (!vertexShader || !fragmentShader) return null;
        const shaderProgram = gl.createProgram(); //distinguish with createshader
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        //two colomns above can be reversed
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
          alert(
            "Unable to initialize the shader program: " +
              gl.getProgramInfoLog(shaderProgram)
          );
          return null;
        }
        return shaderProgram;
      }
      function loadShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        //if compile fail
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error(
            "An error occurred compiling the shaders: " +
              gl.getShaderInfoLog(shader)
          );
          alert(
            "An error occurred compiling the shaders. Check console for details."
          );
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }
      //#endregion
    </script>
  </body>
</html>
