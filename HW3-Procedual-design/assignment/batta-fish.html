<html>
  <head>
    <meta charset="UTF-8" />
    <style>
      html {
        height: 100%;
        margin: 0;
      }
      body {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100%;
      }
      canvas {
        width: 700px;
        height: 700px;
        border-radius: 32px;
        box-shadow: 10px 10px 10px 6px rgba(0, 0, 255, 0.2);
      }
    </style>
  </head>
  <body>
    <canvas id="myCanvas"> </canvas>
    <script>
      //#region glsetup
      /** @type {HTMLCanvasElement} */
      const canvas = document.getElementById("myCanvas");

      /** @type {WebGL2RenderingContext} */
      const gl = canvas.getContext("webgl2");

      if (!gl) {
        alert("WebGL2 not supported in this browser.");
        throw new Error("WebGL2 not supported");
      }
      gl.clearColor(0.2, 0.2, 0.2, 1);
      gl.clear(gl.COLOR_BUFFER_BIT);
      //endregion

      //# region shader
      //note: gl.position is oriented left bottom, and from 0 to 1
      const vsSource = `#version 300 es
      in vec2 position;
      out vec2 vPosition;
      void main() {
        vPosition = position;
        gl_Position = vec4(position, 0.0, 1.0);
      }`;
      const fsSource = `#version 300 es
      precision mediump float;
      in vec2 vPosition;
      out vec4 outColor;
      uniform float vu_time;

      float sdEgg( in vec2 p, in float he, in float ra, in float rb, in float bu )
      {
          // all this can be precomputed for any given shape
          float r = 0.5*(he + ra+rb)/bu;
          float da = r - ra;
          float db = r - rb;
          float y = (db*db - da*da - he*he)/(2.0*he);
          float x = sqrt(da*da - y*y);
          // only this needs to be run per pixel
          p.x = abs(p.x);
          float k = p.y*x - p.x*y;
          if( k>0.0 && k<he*(p.x+x) )
              return length(p+vec2(x,y))-r;
          return min( length(p)-ra,
                      length(vec2(p.x,p.y-he))-rb );
      }
      float getRuffleNoise(float angle, float time) {
          // 3 layer sin
          // layer1: low freq
          float noise = sin(angle * 8.0 + time * 1.5) * 0.5;
          // layer2: med freq
          noise += sin(angle * 17.0 - time * 2.0) * 0.25;
          // layer3: high freq
          noise += sin(angle * 37.0 + time * 3.5) * 0.125;
          return noise * 0.1; // 0.1 controls the strength of ruffle
      }
      float sdBettaTailShape( vec2 p, vec2 c, float r, float iTime )
      {
          // modified from sdPie by Mr. Inigo Quilez
          // additional logi
          // 1. 在 abs(p.x) 之前获取原始角度。atan(y, x) 返回 [-PI, PI]
          float angle = atan(p.y, p.x);
          // 2. 计算基于角度的半径偏移量
          // 我们乘以 r 是为了让褶皱的大小与尾巴整体大小成比例
          float ruffleOffset = getRuffleNoise(angle, iTime) * r;
          // original pie logi
          p.x = abs(p.x);
          // 3. (important) 将固定的半径 r 替换为动态的半径 (r + ruffleOffset)
          // 这样只有外侧的弧形边缘会变得不规则，而两侧的直边保持不变。
          float l = length(p) - (r + ruffleOffset);
          float m = length(p-c*clamp(dot(p,c),0.0,r)); // c=sin/cos of aperture
          return max(l,m*sign(c.y*p.x-c.x*p.y));
      }
      float sdOrientedVesica( vec2 p, vec2 a, vec2 b, float w )
      {
          float r = 0.5*length(b-a);
          float d = 0.5*(r*r-w*w)/w;
          vec2 v = (b-a)/r;
          vec2 c = (b+a)*0.5;
          vec2 q = 0.5*abs(mat2(v.y,v.x,-v.x,v.y)*(p-c));
          vec3 h = (r*q.x<d*(q.y-r)) ? vec3(0.0,r,0.0) : vec3(-d,0.0,d+w);
          return length( q-h.xy) - h.z;
      }
      float smoothUnion(float d1, float d2, float k) {//k represents the factor of smooth
          float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);
          return mix(d2, d1, h) - k * h * (1.0 - h);
      }
      
      void main() {
        vec2 centcoord = vPosition;
        //the head, id:0
        vec2 center0 = centcoord-vec2(0.650,0.460);
        vec2 a0 = vec2(0.320,0.380);
        vec2 b0 = vec2(0.070,0.060);
        float w0 = 0.088;
        float d0 =sdOrientedVesica(center0,a0,b0,w0);
        //the body, id:1
        //**NOTICE: THE ROTATE HERE CAN BE PRE COMPUTED
        vec2 center1 = centcoord-vec2(0.820,0.670);//center definition, same below
        float theta1 = -4.256;
        mat2 rotate1 = mat2(cos(theta1),-sin(theta1),sin(theta1),cos(theta1));
        float he1 = 0.244; // "height"
        float ra1 = 0.102;// Bottom radius
        float rb1 = 0.072;// Top radius
        float bu1 = 0.264;// "width"
        float d1 = sdEgg(rotate1*center1, he1, ra1, rb1, bu1);
        //the tail, id: 2
        //**NOTICE: THE ROTATE HERE CAN BE PRE COMPUTED
        //**NOTICE: THE ITIME HERE SHOULD BE REPLACED
        float theta2 = -4.360;
        mat2 rotate2 = mat2(cos(theta2),-sin(theta2),sin(theta2),cos(theta2));
        vec2 center2 = centcoord - vec2(0.570,0.570);
        vec2 c2 = vec2(0.920,0.280);
        float r2 = 0.500;
        float itime2 = 0.200;
        float d2 = sdBettaTailShape(rotate2*center2,c2,r2,itime2);
        //COMBINE MASK
        //head(0) and body(1) shares one texture
        float d_headbody = smoothUnion(d0,d1,0.048);
        //tail(2) have individual texture
        float d_tail = d2;
        //fins(other) shares one texture

        float d_temp = smoothUnion(d_headbody,d_tail,0.048);
        float mask = step(d_temp,0.0);
        outColor = mask*vec4(vPosition*0.5+0.5,1.0,1.0);
      }`;
      //shader helper
      function compileShader(ingl, type, source) {
        const shader = ingl.createShader(type);
        ingl.shaderSource(shader, source);
        ingl.compileShader(shader);
        if (!ingl.getShaderParameter(shader, ingl.COMPILE_STATUS)) {
          console.error(
            "Shader compile error: " + ingl.getShaderInfoLog(shader)
          );
          ingl.deleteShader(shader);
          return null;
        }
        return shader;
      }
      function initShaderProgram(ingl, vsSrc, fsSrc) {
        const vertexShader = compileShader(ingl, ingl.VERTEX_SHADER, vsSrc);
        const fragmentShader = compileShader(ingl, ingl.FRAGMENT_SHADER, fsSrc);
        const prog = ingl.createProgram();
        ingl.attachShader(prog, vertexShader);
        ingl.attachShader(prog, fragmentShader);
        ingl.linkProgram(prog);
        if (!ingl.getProgramParameter(prog, ingl.LINK_STATUS)) {
          console.error(
            "Unable to initialize the shader program: " +
              ingl.getProgramInfoLog(prog)
          );
          return null;
        }
        ingl.deleteShader(vertexShader);
        ingl.deleteShader(fragmentShader);
        return prog;
      }

      const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
      gl.useProgram(shaderProgram);
      //endregion
      const posIn = gl.getAttribLocation(shaderProgram, "position");
      //#region geometry
      const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
      //endregion
      const vao = gl.createVertexArray();
      const vbo = gl.createBuffer();
      gl.bindVertexArray(vao);
      gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
      gl.enableVertexAttribArray(posIn);
      gl.vertexAttribPointer(posIn, 2, gl.FLOAT, false, 0, 0);
      gl.bindVertexArray(null);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);

      // old draw
      // gl.bindVertexArray(vao);
      // gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

      requestAnimationFrame(draw);

      function draw(time) {
        //animation loop ver
        time *= 0.001;
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.bindVertexArray(vao);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        requestAnimationFrame(draw);
      }
    </script>
  </body>
</html>
