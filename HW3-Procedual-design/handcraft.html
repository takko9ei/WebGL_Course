<html>
  <head>
    <meta charset="UTF-8" />
    <style>
      html {
        height: 100%;
        margin: 0;
      }
      body {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100%;
      }
      canvas {
        width: 800px;
        height: 800px;
        border-radius: 32px;
        box-shadow: 10px 10px 10px 6px rgba(0, 0, 255, 0.2);
      }
    </style>
  </head>
  <body>
    <canvas id="myCanvas"> </canvas>
    <script>
      //#region glsetup
      /** @type {HTMLCanvasElement} */
      const canvas = document.getElementById("myCanvas");

      /** @type {WebGL2RenderingContext} */
      const gl = canvas.getContext("webgl2");

      if (!gl) {
        alert("WebGL2 not supported in this browser.");
        throw new Error("WebGL2 not supported");
      }
      gl.clearColor(0.2, 0.2, 0.2, 1);
      gl.clear(gl.COLOR_BUFFER_BIT);
      //endregion

      //# region shader
      const vsSource = `#version 300 es
      in vec2 position;
      out vec3 vPosition;
      void main() {
        vPosition = vec3(position*0.5+0.5,1.0);
        gl_Position = vec4(position, 0.0, 1.0);
      }`;
      const fsSource = `#version 300 es
      precision mediump float;
      in vec3 vPosition;
      out vec4 outColor;
      void main() {
        outColor = vec4(vPosition, 1.0);
      }`;

      //shader helper
      function compileShader(ingl, type, source) {
        const shader = ingl.createShader(type);
        ingl.shaderSource(shader, source);
        ingl.compileShader(shader);
        if (!ingl.getShaderParameter(shader, ingl.COMPILE_STATUS)) {
          console.error(
            "Shader compile error: " + ingl.getShaderInfoLog(shader)
          );
          ingl.deleteShader(shader);
          return null;
        }
        return shader;
      }
      function initShaderProgram(ingl, vsSrc, fsSrc) {
        const vertexShader = compileShader(ingl, ingl.VERTEX_SHADER, vsSrc);
        const fragmentShader = compileShader(ingl, ingl.FRAGMENT_SHADER, fsSrc);
        const prog = ingl.createProgram();
        ingl.attachShader(prog, vertexShader);
        ingl.attachShader(prog, fragmentShader);
        ingl.linkProgram(prog);
        if (!ingl.getProgramParameter(prog, ingl.LINK_STATUS)) {
          console.error(
            "Unable to initialize the shader program: " +
              ingl.getProgramInfoLog(prog)
          );
          return null;
        }
        ingl.deleteShader(vertexShader);
        ingl.deleteShader(fragmentShader);
        return prog;
      }

      const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
      gl.useProgram(shaderProgram);
      //endregion
      const posIn = gl.getAttribLocation(shaderProgram, "position");
      //#region geometry
      const vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
      //endregion
      const vao = gl.createVertexArray();
      const vbo = gl.createBuffer();
      gl.bindVertexArray(vao);
      gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
      gl.enableVertexAttribArray(posIn);
      gl.vertexAttribPointer(posIn, 2, gl.FLOAT, false, 0, 0);
      gl.bindVertexArray(null);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);

      gl.bindVertexArray(vao);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    </script>
  </body>
</html>
