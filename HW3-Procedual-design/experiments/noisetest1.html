<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Procedural Texture Viewer</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
      }
      canvas {
        display: block;
        width: 100vw;
        height: 100vh;
      }
    </style>
  </head>
  <body>
    <canvas id="glCanvas"></canvas>

    <script id="vertexShader" type="x-shader/x-vertex">
      attribute vec4 position;
      void main() {
          gl_Position = position;
      }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
            precision mediump float;

      uniform vec2 iResolution;
      uniform float iTime;

      void main() {
          // 1. Setup Coordinates
          // 保持长宽比，将中心设为 (0,0) 以便对称操作
          vec2 uv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;
          vec2 u0 = uv; // 保存原始坐标，用于计算最终的亮度衰减

          // --- Configuration (参数调优) ---
          // 想要变成更像“丝绸”还是“水草”，主要调这里
          float speed = 0.5;      // 摆动速度
          float density = 8.0;    // 线条的密度
          int iterations = 5;     // 叠加层数（越多越复杂，但性能开销大）

          // --- 2. The "Silk" Loop (Iterative Domain Warping) ---
          // 核心循环：不断扭曲 UV 坐标
          // 每一次循环，坐标都会被加上一个基于当前坐标的正弦波偏移量
          // 这模拟了流体一层带一层运动的效果
          for (int i = 0; i < 5; i++) { // WebGL 循环次数最好是常数
              float fi = float(i);

              // Calculate a wave based on current UV and Time
              // 这里的魔术数字 (1.0, 0.7, etc) 是为了打破对称性，让摆动看起来自然不重复
              uv.x += 0.2 / (fi + 1.0) * sin(fi * 3.0 * uv.y + iTime * speed + 0.3 * fi) + 0.5;
              uv.y += 0.1 / (fi + 1.0) * sin(fi * 3.0 * uv.x + iTime * speed * 1.2 + 0.3 * (fi + 10.0)) - 0.5;
          }

          // --- 3. Pattern Generation ---
          // 经过上面的循环，uv 已经被扭曲得非常复杂了。
          // 现在我们用这个扭曲后的 uv 来生成正弦条纹。

          // sin(uv.x + uv.y) 生成波浪纹
          // 乘上 density 控制疏密
          float pattern = sin(uv.x * density + uv.y * density);

          // Make lines thinner and sharper (Seaweed/Silk strands)
          // 通过 absolute 和 倒数，把正弦波变成一条条发光的“线”
          pattern = abs(pattern);
          pattern = 0.1 / pattern; // 类似于发光效果 (Glow)

          // --- 4. Coloring ---

          // Base Color: Deep Sea Blue/Green (深海蓝绿)
          vec3 col = vec3(0.1, 0.6, 0.5);

          // Add color variation based on the warped coordinates
          // 让颜色随着扭曲变化，产生丝绸的反光感
          col += vec3(0.2, 0.1, 0.4) * sin(uv.y);

          // Apply the pattern brightness
          col *= pattern;

          // --- 5. Vignette & Fade (Optional) ---
          // 让四周暗一点，聚焦中心
          float vignette = 1.5 - length(u0);
          col *= vignette;

          // Output
          gl_FragColor = vec4(col, 1.0);
      }
    </script>

    <script>
      // --- JavaScript Boilerplate to Setup WebGL ---

      const canvas = document.getElementById("glCanvas");
      const gl = canvas.getContext("webgl");

      if (!gl) {
        alert("WebGL not supported");
      }

      // 1. Compile Shader Function
      // 编译着色器的辅助函数
      function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error(gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }

      // 2. Get Shader Source Code from HTML scripts
      // 获取 Shader 源码
      const vsSource = document.getElementById("vertexShader").text;
      const fsSource = document.getElementById("fragmentShader").text;

      // 3. Create and Link Program
      // 创建并链接程序
      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);

      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(program));
      }

      gl.useProgram(program);

      // 4. Setup Geometry (A big rectangle covering the screen)
      // 设置几何体（覆盖全屏的大矩形）
      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      const positions = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array(positions),
        gl.STATIC_DRAW
      );

      const positionAttributeLocation = gl.getAttribLocation(
        program,
        "position"
      );
      gl.enableVertexAttribArray(positionAttributeLocation);
      gl.vertexAttribPointer(
        positionAttributeLocation,
        2,
        gl.FLOAT,
        false,
        0,
        0
      );

      // 5. Get Uniform Locations
      // 获取 Uniform 变量的位置
      const resolutionLocation = gl.getUniformLocation(program, "iResolution");
      const timeLocation = gl.getUniformLocation(program, "iTime");

      // 6. Render Loop
      // 渲染循环
      function render(time) {
        time *= 0.001; // Convert to seconds

        // Resize canvas to full screen
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);

        // Pass uniforms to shader
        // 传递参数给 Shader
        gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
        gl.uniform1f(timeLocation, time);

        // Draw
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        requestAnimationFrame(render);
      }

      requestAnimationFrame(render);
    </script>
  </body>
</html>
