<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Procedural Texture Viewer</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #000;
      }
      canvas {
        display: block;
        width: 100vw;
        height: 100vh;
      }
    </style>
  </head>
  <body>
    <canvas id="glCanvas"></canvas>

    <script id="vertexShader" type="x-shader/x-vertex">
      attribute vec4 position;
      void main() {
          gl_Position = position;
      }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
                  precision mediump float;

            uniform vec2 iResolution;
            uniform float iTime;

            void main() {
          // 1. Setup Coordinates
          // 保持长宽比
          vec2 uv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;
          vec2 u0 = uv; // 保存原始坐标用于遮罩

          // --- Configuration (参数调优) ---
          float speed = 0.5;      // 摆动速度
          float density = 8.0;    // 线条的基础密度

          // --- 2. Spindle Shape Shaping (纺锤形重映射) ---
          // 使用 cos 来模拟自然的纺锤弧度。
          // clamp 限制范围防止除零错误。
          // uv.x * 1.2 控制纺锤的宽窄（数值越小纺锤越宽）
          float shapeFactor = cos(clamp(uv.x * 1.2, -1.57, 1.57));

          // 核心技巧：
          // 将 UV.y 除以 shapeFactor。
          // 当靠近中心时(shapeFactor接近1)，y坐标不变。
          // 当靠近两端时(shapeFactor变小)，y坐标变大，纹理变得非常密集，产生视觉上的“收缩”感。
          // + 0.2 是为了防止边缘完全拉丝到无限细，保留一点厚度。
          uv.y /= (shapeFactor * shapeFactor + 0.1);

          // --- 3. The "Silk" Loop (Iterative Domain Warping) ---
          // 减少循环次数到 4，去除过多的高频噪点，让线条更顺滑
          for (int i = 0; i < 4; i++) {
              float fi = float(i);

              // 调整摆动参数：
              // 0.15 (原0.2) -> 减小振幅，让摆动更克制
              // speed * 0.5 -> 让波动的传递稍微慢一点，显得更优雅
              float offset = 0.15 / (fi + 1.0) * sin(fi * 3.0 * uv.y + iTime * speed + 0.3 * fi) + 0.5;

              // 只对 X 做主要扭曲，对 Y 做轻微扭曲，保持纺锤的横向趋势
              uv.x += offset;
              uv.y += 0.1 / (fi + 1.0) * sin(fi * 4.0 * uv.x + iTime * speed * 0.8);
          }

          // --- 4. Pattern Generation ---
          // 生成波纹
          float pattern = sin(uv.x * density + uv.y * density);

          // 锐化线条：使用 smoothstep 代替简单的倒数，边缘会更平滑抗锯齿
          pattern = abs(pattern);
          pattern = 0.05 / max(pattern, 0.001); // max防止除0

          // 限制线条的最大亮度，防止过曝
          pattern = min(pattern, 2.0);

          // --- 5. Coloring ---
          // Base Color: 你的深海蓝绿配色
          vec3 col = vec3(0.1, 0.6, 0.5);

          // Color Variation: 让颜色随原始 Y 轴和扭曲后的 Y 轴变化
          col += vec3(0.2, 0.1, 0.4) * sin(u0.y * 2.0 + uv.y);

          // Apply Pattern
          col *= pattern;

          // --- 6. Spindle Mask (形状遮罩) ---
          // 这是最关键的一步：之前只是扭曲了坐标，现在要把不需要的部分“切掉”。
          // 利用之前的 shapeFactor (基于cos的曲线) 来生成透明度。
          // pow(..., 3.0) 用来调整边缘的硬度，让它两端渐变消失。
          float mask = smoothstep(0.0, 1.0, shapeFactor);
          mask = pow(mask, 3.0); // 增加对比度，让纺锤更尖锐

          // 额外添加一点基于 Y 轴的衰减，防止上下溢出屏幕太多
          //float vFade = 1.0 - smoothstep(0.5, 1.0, abs(u0.y));

          col *= mask;// * vFade;

          // Output
          gl_FragColor = vec4(col, 1.0);
      }
    </script>

    <script>
      // --- JavaScript Boilerplate to Setup WebGL ---

      const canvas = document.getElementById("glCanvas");
      const gl = canvas.getContext("webgl");

      if (!gl) {
        alert("WebGL not supported");
      }

      // 1. Compile Shader Function
      // 编译着色器的辅助函数
      function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error(gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }

      // 2. Get Shader Source Code from HTML scripts
      // 获取 Shader 源码
      const vsSource = document.getElementById("vertexShader").text;
      const fsSource = document.getElementById("fragmentShader").text;

      // 3. Create and Link Program
      // 创建并链接程序
      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);

      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(program));
      }

      gl.useProgram(program);

      // 4. Setup Geometry (A big rectangle covering the screen)
      // 设置几何体（覆盖全屏的大矩形）
      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      const positions = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array(positions),
        gl.STATIC_DRAW
      );

      const positionAttributeLocation = gl.getAttribLocation(
        program,
        "position"
      );
      gl.enableVertexAttribArray(positionAttributeLocation);
      gl.vertexAttribPointer(
        positionAttributeLocation,
        2,
        gl.FLOAT,
        false,
        0,
        0
      );

      // 5. Get Uniform Locations
      // 获取 Uniform 变量的位置
      const resolutionLocation = gl.getUniformLocation(program, "iResolution");
      const timeLocation = gl.getUniformLocation(program, "iTime");

      // 6. Render Loop
      // 渲染循环
      function render(time) {
        time *= 0.001; // Convert to seconds

        // Resize canvas to full screen
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);

        // Pass uniforms to shader
        // 传递参数给 Shader
        gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
        gl.uniform1f(timeLocation, time);

        // Draw
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        requestAnimationFrame(render);
      }

      requestAnimationFrame(render);
    </script>
  </body>
</html>
