<html>
  <head>
    <title>WebGL HW2 - Ramiel Scene</title>
    <style>
      body {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
        background: #333;
      }
      canvas {
        border: 1px solid white;
        /* Ensure canvas uses the full viewport if needed, but we respect the explicit size */
      }
    </style>
  </head>
  <body>
    <canvas id="glCanvas" width="640" height="480" />

    <script id="vertex-shader" type="notjs">
      #version 300 es

      // Input: Vertex position from the VBO
      in vec3 pos;

      // Uniforms: Matrices set from JavaScript
      uniform mat4 uModelMatrix;
      uniform mat4 uViewMatrix;
      uniform mat4 uProjectionMatrix;

      // Output: Pass the view-space depth to the fragment shader
      out float vDepth;

      void main() {
        // Calculate the position in View Space (relative to the camera)
        vec4 viewPosition = uViewMatrix * uModelMatrix * vec4(pos, 1.0);

        // Calculate the final position in Clip Space
        gl_Position = uProjectionMatrix * viewPosition;

        // Pass the Z-coordinate (depth) to the fragment shader
        // In view space, Z is negative, so -5 is closer than -20.
        vDepth = viewPosition.z;
      }
    </script>

    <script id="fragment-shader" type="notjs">
      #version 300 es
      precision mediump float;

      // Input: Interpolated depth from the vertex shader
      in float vDepth;

      // Uniform: The base color for the object (blue for Ramiel, grey for floor)
      uniform vec3 uBaseColor;

      // Output: The final pixel color
      out vec4 color_out;

      void main() {
        // Define the visualization range in View Space (camera-relative)
        // We want full brightness around z = -4
        float z_near_vis = -4.0;
        // We want minimum brightness around z = -25
        float z_far_vis = -25.0;

        // Normalize vDepth (which is negative) into a 0.0 (far) to 1.0 (near) range
        float depthFactor = (vDepth - z_far_vis) / (z_near_vis - z_far_vis);

        // Clamp to ensure it's within [0, 1]
        depthFactor = clamp(depthFactor, 0.0, 1.0);

        // Use mix() to map the 0-1 range to a [min_brightness, 1.0] range
        // This prevents the object from becoming pure black
        float brightness = mix(0.2, 1.0, depthFactor); // 0.2 = min brightness, 1.0 = max

        // Final color is the base color multiplied by the depth-based brightness
        color_out = vec4(uBaseColor * brightness, 1.0);
      }
    </script>

    <script>
      // A minimal matrix math library for 4x4 matrices (mat4)
      const MiniMat = {
        create: () => new Float32Array(16),
        identity: (out) => {
          out.fill(0);
          out[0] = out[5] = out[10] = out[15] = 1;
          return out;
        },
        multiply: (out, a, b) => {
          let a00 = a[0],
            a01 = a[1],
            a02 = a[2],
            a03 = a[3],
            a10 = a[4],
            a11 = a[5],
            a12 = a[6],
            a13 = a[7],
            a20 = a[8],
            a21 = a[9],
            a22 = a[10],
            a23 = a[11],
            a30 = a[12],
            a31 = a[13],
            a32 = a[14],
            a33 = a[15];
          let b0 = b[0],
            b1 = b[1],
            b2 = b[2],
            b3 = b[3];
          out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = b[4];
          b1 = b[5];
          b2 = b[6];
          b3 = b[7];
          out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = b[8];
          b1 = b[9];
          b2 = b[10];
          b3 = b[11];
          out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          b0 = b[12];
          b1 = b[13];
          b2 = b[14];
          b3 = b[15];
          out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
          out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
          out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
          out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
          return out;
        },
        perspective: (out, fovy, aspect, near, far) => {
          const f = 1.0 / Math.tan(fovy / 2);
          out.fill(0);
          out[0] = f / aspect;
          out[5] = f;
          out[10] = (far + near) / (near - far);
          out[11] = -1;
          out[14] = (2 * far * near) / (near - far);
          return out;
        },
        lookAt: (out, eye, center, up) => {
          let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
          z0 = eye[0] - center[0];
          z1 = eye[1] - center[1];
          z2 = eye[2] - center[2];
          len = 1 / Math.hypot(z0, z1, z2);
          z0 *= len;
          z1 *= len;
          z2 *= len;
          x0 = up[1] * z2 - up[2] * z1;
          x1 = up[2] * z0 - up[0] * z2;
          x2 = up[0] * z1 - up[1] * z0;
          len = 1 / Math.hypot(x0, x1, x2);
          x0 *= len;
          x1 *= len;
          x2 *= len;
          y0 = z1 * x2 - z2 * x1;
          y1 = z2 * x0 - z0 * x2;
          y2 = z0 * x1 - z1 * x0;
          out[0] = x0;
          out[1] = y0;
          out[2] = z0;
          out[3] = 0;
          out[4] = x1;
          out[5] = y1;
          out[6] = z1;
          out[7] = 0;
          out[8] = x2;
          out[9] = y2;
          out[10] = z2;
          out[11] = 0;
          out[12] = -(x0 * eye[0] + x1 * eye[1] + x2 * eye[2]);
          out[13] = -(y0 * eye[0] + y1 * eye[1] + y2 * eye[2]);
          out[14] = -(z0 * eye[0] + z1 * eye[1] + z2 * eye[2]);
          out[15] = 1;
          return out;
        },
        translate: (out, a, v) => {
          // Note: This is a simple translate, not a full post-multiply translate
          if (a !== out) MiniMat.identity(out);
          out[12] = a[12] + v[0];
          out[13] = a[13] + v[1];
          out[14] = a[14] + v[2];
          return out;
        },
        rotate: (out, a, rad, axis) => {
          let x = axis[0],
            y = axis[1],
            z = axis[2],
            len = Math.hypot(x, y, z);
          if (len < 1e-6) return null;
          len = 1 / len;
          x *= len;
          y *= len;
          z *= len;
          let s = Math.sin(rad),
            c = Math.cos(rad),
            t = 1 - c;
          let a00 = a[0],
            a01 = a[1],
            a02 = a[2],
            a03 = a[3],
            a10 = a[4],
            a11 = a[5],
            a12 = a[6],
            a13 = a[7],
            a20 = a[8],
            a21 = a[9],
            a22 = a[10],
            a23 = a[11];
          let b00 = x * x * t + c,
            b01 = y * x * t + z * s,
            b02 = z * x * t - y * s,
            b10 = x * y * t - z * s,
            b11 = y * y * t + c,
            b12 = z * y * t + x * s,
            b20 = x * z * t + y * s,
            b21 = y * z * t - x * s,
            b22 = z * z * t + c;
          out[0] = a00 * b00 + a10 * b01 + a20 * b02;
          out[1] = a01 * b00 + a11 * b01 + a21 * b02;
          out[2] = a02 * b00 + a12 * b01 + a22 * b02;
          out[3] = a03 * b00 + a13 * b01 + a23 * b02;
          out[4] = a00 * b10 + a10 * b11 + a20 * b12;
          out[5] = a01 * b10 + a11 * b11 + a21 * b12;
          out[6] = a02 * b10 + a12 * b11 + a22 * b12;
          out[7] = a03 * b10 + a13 * b11 + a23 * b12;
          out[8] = a00 * b20 + a10 * b21 + a20 * b22;
          out[9] = a01 * b20 + a11 * b21 + a21 * b22;
          out[10] = a02 * b20 + a12 * b21 + a22 * b22;
          out[11] = a03 * b20 + a13 * b21 + a23 * b22;
          if (a !== out) {
            out[12] = a[12];
            out[13] = a[13];
            out[14] = a[14];
            out[15] = a[15];
          }
          return out;
        },
      };

      //#region variables
      // ... (floorVertices 保持不变)
      const floorVertices = [
        -10.0, -2, 10.0, 10.0, -2.5, 10.0, -10.0, -2.5, -10.0, 10.0, -2.5,
        -10.0,
      ];

      // --- Ramiel (正八面体) ---
      const vTop = [0.0, 3.0, 0.0];
      const vBottom = [0.0, -3.0, 0.0];
      const vLeft = [-2.0, 0.0, 0.0];
      const vRight = [2.0, 0.0, 0.0];
      const vFront = [0.0, 0.0, 2.0];
      const vBack = [0.0, 0.0, -2.0];

      // 条带 1: 上半部分金字塔 (4 个三角形, 6 个顶点, 逆时针 CCW)

      const ramielTopStrip = [
        ...vTop,
        ...vLeft,
        ...vFront,
        ...vBottom,
        ...vRight,
        ...vBack,
      ];

      // 条带 2: 下半部分金字塔 (4 个三角形, 6 个顶点, 逆时针 CCW)
      const ramielBottomStrip = [
        ...vBottom,
        ...vLeft,
        ...vBack,
        ...vTop,
        ...vRight,
        ...vFront,
      ];

      // 合并为一个单一的、12顶点的条带
      // GPU 将自动处理 vFront,vFront,vLeft 处的退化三角形
      const ramielVertices = [...ramielTopStrip, ...ramielBottomStrip];

      // (我们不再需要 ramielTopVertCount 和 ramielBottomVertCount)
      //#endregion

      //#region initialization
      const canvas = document.getElementById("glCanvas");
      const gl = canvas.getContext("webgl2");
      if (!gl) throw new Error("WebGL 2.0 unsupported!");

      // Set the background color (light blue)
      gl.clearColor(0.8, 0.9, 1.0, 1.0); // R, G, B, A

      // Enable depth testing for 3D occlusion
      gl.enable(gl.DEPTH_TEST);
      //#endregion

      //#region shader setup
      const vsSource = document.getElementById("vertex-shader").text.trim();
      const fsSource = document.getElementById("fragment-shader").text.trim();
      const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
      // Note: gl.useProgram is now called inside the render loop
      //#endregion

      //#region bind (Geometry Setup)

      /**
       * Helper function to create a VAO and VBO for a given geometry.
       * @param {WebGL2RenderingContext} gl - The WebGL context
       * @param {WebGLProgram} program - The shader program
       * @param {Array<number>} vertices - The vertex data (flat array)
       * @returns {{vao: WebGLVertexArrayObject, count: number}}
       */
      function initGeometry(gl, program, vertices) {
        const vao = gl.createVertexArray();
        const vbo = gl.createBuffer();

        gl.bindVertexArray(vao);
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(vertices),
          gl.STATIC_DRAW
        );

        // Get the location of the 'pos' attribute in the shader
        const posAttrib = gl.getAttribLocation(program, "pos");
        gl.enableVertexAttribArray(posAttrib);

        // Tell WebGL how to read the VBO
        // index, size (3=vec3), type, normalized, stride, offset
        gl.vertexAttribPointer(posAttrib, 3, gl.FLOAT, false, 0, 0);

        gl.bindVertexArray(null); // Unbind the VAO

        return {
          vao: vao,
          count: vertices.length / 3, // Number of vertices
        };
      }

      // Create the geometry (VAO/VBO) for our two objects
      const floorGeometry = initGeometry(gl, shaderProgram, floorVertices);
      const ramielGeometry = initGeometry(gl, shaderProgram, ramielVertices);

      // Get locations of all uniforms once (for efficiency)
      const uniformLocations = {
        modelMatrix: gl.getUniformLocation(shaderProgram, "uModelMatrix"),
        viewMatrix: gl.getUniformLocation(shaderProgram, "uViewMatrix"),
        projectionMatrix: gl.getUniformLocation(
          shaderProgram,
          "uProjectionMatrix"
        ),
        baseColor: gl.getUniformLocation(shaderProgram, "uBaseColor"),
      };
      //#endregion

      //#region draw (Render Loop)

      // --- Create Camera Matrices ---

      // Create a perspective projection matrix (the "lens")
      const projectionMatrix = MiniMat.create();
      MiniMat.perspective(
        projectionMatrix,
        (45 * Math.PI) / 180, // 45-degree field of view
        canvas.clientWidth / canvas.clientHeight, // aspect ratio
        0.1, // near clip plane
        100.0 // far clip plane
      );

      // Create a view matrix (the "camera position")
      const viewMatrix = MiniMat.create();
      // Position the camera at (0, 5, 12), look at (0,0,0), with (0,1,0) as "up"
      MiniMat.lookAt(viewMatrix, [0, 5, 12], [0, 0, 0], [0, 1, 0]);

      // --- Create Model Matrices ---
      const floorModelMatrix = MiniMat.create();
      MiniMat.identity(floorModelMatrix); // Floor doesn't move

      const ramielModelMatrix = MiniMat.create();
      // We will update this one every frame

      /**
       * The main render loop function.
       * @param {number} time - Time elapsed since page load (in milliseconds)
       */
      function drawScene(time) {
        time *= 0.001; // Convert time to seconds

        // 1. Prepare for drawing
        // Clear the color and depth buffers
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        // Tell WebGL to use our shader program
        gl.useProgram(shaderProgram);

        // 2. Set camera uniforms (same for all objects)
        gl.uniformMatrix4fv(
          uniformLocations.projectionMatrix,
          false,
          projectionMatrix
        );
        gl.uniformMatrix4fv(uniformLocations.viewMatrix, false, viewMatrix);

        // 3. Draw the Floor
        gl.bindVertexArray(floorGeometry.vao); // Activate floor's geometry
        gl.uniformMatrix4fv(
          uniformLocations.modelMatrix,
          false,
          floorModelMatrix
        );
        gl.uniform3f(uniformLocations.baseColor, 0.5, 0.5, 0.5); // Set color to grey
        // Draw using TRIANGLE_STRIP, starting at vertex 0, drawing 'count' vertices
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, floorGeometry.count);

        // 4. Draw Ramiel
        gl.bindVertexArray(ramielGeometry.vao); // 激活 Ramiel 的 VAO

        // 计算 Ramiel 的新变换 (不变)
        MiniMat.identity(ramielModelMatrix);
        MiniMat.translate(ramielModelMatrix, ramielModelMatrix, [0, 1.5, 0]);
        MiniMat.rotate(
          ramielModelMatrix,
          ramielModelMatrix,
          time * 0.5,
          [0, 1, 0]
        );

        // 发送矩阵和颜色 (不变)
        gl.uniformMatrix4fv(
          uniformLocations.modelMatrix,
          false,
          ramielModelMatrix
        );
        gl.uniform3f(uniformLocations.baseColor, 0.2, 0.4, 1.0); // 蓝色

        // *** 修正的绘制流程 ***
        // 使用 ramielGeometry.count (它应该是 12)
        gl.drawArrays(
          gl.TRIANGLE_STRIP,
          0,
          ramielGeometry.count // 绘制所有 12 个顶点
        );

        // 5. 请求下一帧 (不变)
        requestAnimationFrame(drawScene);
      }

      // Start the render loop
      requestAnimationFrame(drawScene);

      //#endregion

      //#region shader helper functions (Unchanged from your framework)
      function initShaderProgram(gl, vsSource, fsSource) {
        const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
        if (!vertexShader || !fragmentShader) return null;
        const shaderProgram = gl.createProgram(); //distinguish with createshader
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        //two colomns above can be reversed
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
          alert(
            "Unable to initialize the shader program: " +
              gl.getProgramInfoLog(shaderProgram)
          );
          return null;
        }
        return shaderProgram;
      }
      function loadShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        console.log("Compiling shader:\n" + source);

        gl.compileShader(shader);
        //if compile fail
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error(
            "An error occurred compiling the shaders: " +
              gl.getShaderInfoLog(shader)
          );
          alert(
            "An error occurred compiling the shaders. Check console for details."
          );
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }
      //#endregion
    </script>
  </body>
</html>
